WebAppSec /安全编码指南
< WebAppSec
内容
介绍

本页面的目的是建立一个简洁而一致的方法来保护Mozilla Web应用程序和Web服务的应用程序开发。这里提供的信息将着重于基于网络的应用程序; 然而，这些概念可以普遍应用于应用程序以实现完善的安全控制和设计。

该页面主要关注安全准则，并可能在稍后提供示例代码。

状态

安全编码指南页面是一个活跃的文档，并不断更新以反映新的建议和技术。列出的信息是准确的，可以立即用于提高应用程序的安全性。如果您有任何意见，建议或疑虑，请发送电子邮件至mcoates <at> mozilla.com

布局

准则在逻辑安全领域内进行讨论。我们没有讨论如何防止每种类型的攻击，而是专注于设计应用程序的安全方法。在每个部分中，列出了这些控件旨在防范的攻击类型。但是，本文档并非旨在深入分析攻击类型，而是创建安全应用程序的指南。

易快速赢得

以下是一些经常遗漏的项目，并且与大多数每个网站都有关。

对于所有cookie设置HTTPOnly和Secure标志
确保仅在HTTPS上提供登录页面，并且所有经过身份验证的页面仅在HTTPS上提供
不要相信任何用户数据（输入，标题，cookies等）。确保在使用它之前验证它
安全编码指南

认证
关注的攻击

在线和离线强力密码猜测
用户枚举
大规模帐户锁定（帐户DoS）
离线散列破解（时间折衷）
丢失的密码
密码复杂性
所有网站都应该有以下基本密码策略：

密码必须是8个字符或更大
密码必须要求字母和数字
应列入黑名单密码（联系infrasec列表）
关键站点
例如：addons.mozilla.org，bugzilla.mozilla.org或其他关键网站。

关键网站应该将以下要求添加到密码策略中：

除基本策略外，密码还应至少包含一个或多个特殊字符。
密码轮换
密码轮换已被证明有点棘手，只有在应用程序内缺乏监控并且存在使用轮转的减轻原因时才应使用此密码。原因是短密码或缺少密码控制。

特权帐户 - 特权帐户的密码应每90至120天轮换一次。
一般用户帐户 - 如果可能，还建议为普通用户实施密码轮换。
日志条目 - 应生成此事件的应用程序日志条目。
帐户锁定和失败登录
帐户锁定与登录失败应根据应用程序进行评估。在任何一种情况下，应用程序都应该能够确定所使用的密码是否一遍又一遍地重复使用，或者使用不同的密码来指示攻击。

这两种情况的错误消息应该是通用的，例如：

无效登录尝试（出于任何原因）应返回通用错误消息

 您输入的用户名或密码无效
日志记录对于这些事件至关重要，因为它们将馈入我们的安全事件系统，然后我们可以根据这些事件采取行动。应用程序也应该采取行动。例如，在用户遭到攻击的情况下，应用程序应通过呈现验证码或对该IP地址执行时间延迟来停止和/或减慢该用户进度。在达到失败次数限制时，应该在所有情况下都使用验证码。

密码重置功能
密码重置页面将接受用户名，然后发送一封电子邮件，其中包含密码重置链接，指向该帐户的存储电子邮件地址。

无论用户名或电子邮件地址是否有效，都应将以下消息返回给用户：

一封电子邮件已发送至所请求的账户并提供更多信息。如果
 您没有收到电子邮件，请确认您输入的内容相同   
 帐户注册时使用的电子邮件地址
我们不希望提供允许攻击者确定输入的用户名/电子邮件地址是否有效的任何信息。否则，攻击者可能会列举有效的网络钓鱼攻击或暴力攻击帐户。

电子邮件更改和验证功能
电子邮件验证链接不应向用户提供已验证的会话。

电子邮件验证码必须在第一次使用后过期，如果未使用，则必须在8小时后过期。

密码存储
与密码策略不同，我们在存储密码时应该遵循以下标准：

存储在数据库中的密码应该使用hmac + bcrypt函数。
hmac和bcrypt存储的目的如下：

bcrypt提供了一种哈希机制，可以将其配置为消耗足够的时间来防止即使对于许多计算机仍然使用哈希值
bcrypt可以随时轻松调整，以增加工作量，从而为更强大的系统提供保护
hmac值的随机数旨在存储在文件系统中，而不是存储在存储密码哈希的数据库中。如果由于SQL注入而导致散列值受到损害，那么随机数仍然是一个未知值，因为它不会从文件系统中受到影响。这显着增加了暴力破解考虑了bcrypt和大的未知nonce值的复杂性
如果bcrypt可能会泄露密码信息或帮助攻击者进行设计，hmac操作仅用作辅助防御
这段代码的示例在这里：https：//github.com/fwenzel/django-sha2

请记住，尽管bcrypt是安全的，但您仍然应该执行良好的密码。如果密码是“123”，算法可能会很慢，但在有人将其计算出来之前，只需要很短的时间。

旧密码哈希
应该从系统中删除超过一年的密码哈希值。
密码哈希迁移后，如果用户尚未登录进行转换过程，应在3个月内删除旧哈希值。
移民
以下过程可用于迁移使用与上面列出的标准哈希不同的哈希算法的应用程序。这种方法的好处是它可以立即将所有哈希升级到强大的推荐哈希算法，并且不需要用户重置密码。

迁移过程
按如下方式迁移数据库中的所有密码哈希条目。这是一次性离线迁移。

以数据库形式存储：{algo} $ {salt} $ {migration_hash}

   * {算法}是{sha512 + MD5}，
   * {salt}是每个用户唯一的盐，
   * {migration_hash}是SHA512（salt + existingPasswordHash）
新帐户或密码更改的新哈希处理
使用标准哈希处理[ 上述 ]

新登录过程
1.尝试使用迁移哈希登录用户。这包括执行旧的密码哈希程序，然后添加盐，最后执行sha512。

例如：旧密码哈希过程是md5
迁移哈希= sha512（perUserSalt + md5（用户提供的密码））
2.如果通过迁移哈希验证成功：

- 使用用户提供的密码，并根据上面定义的算法计算New Hash。

- 用新哈希覆盖迁移哈希

3.如果通过迁移哈希验证不成功：

- 用户可能已经在New Hash上。尝试使用新的散列直接进行身份验证。如果失败，那么用户提供的密码是错误的。

会话管理
关注的攻击：会话劫持，会话固定，暴力强制有效会话ID

会话ID长度
会话令牌应该是128位或更大

会话ID创建
会话令牌应尽可能由Web服务器处理，或者通过密码安全的随机数生成器生成。

不活动超时
已确认的会话在确定的不活动时间段后应超时 - 建议15分钟。

安全标志
应该在每个set-cookie期间设置“安全”标志。这将指示浏览器不要通过HTTP发送cookie。此标志的目的是防止用户在遵循HTTP链接时意外暴露cookie值。

代码示例

仅HTTP标志
应该设置“HTTP-Only”标志以禁止恶意脚本访问会话ID（例如XSS）

登录
新的会话ID应在登录时创建（以防止通过XSS在兄弟域或子域上修复会话）。

登出
注销后，会话ID应在服务器端失效，并通过到期/覆盖该值在客户端上删除。

访问控制
关注的攻击枚举针对性攻击的网站功能，执行未经授权的功能，查看或修改未经授权的数据

表示层
显示给用户的功能和功能

建议不要显示用户无法访问的链接或功能。其目的是最大限度地减少不必要的访问控制消息，并将不必要的特权信息提供给用户。

业务层
在执行操作之前检查访问控制

确保在系统内执行操作之前执行访问控制检查。用户可以编写自定义的GET或POST消息来尝试执行未经授权的功能。

数据层
考虑目标数据检查访问控制

确保访问控制检查还验证用户是否有权对目标数据执行操作。不要认为被授权执行操作X的用户能够在所有数据集上执行此操作。

输入验证
关注的攻击：引入肮脏/格式错误的数据

输入验证目标
输入验证是为了尽量减少进入系统的错误数据。输入验证不是防止XSS，SQL注入的主要方法。这些在下面的输出编码中被涵盖。

输入验证必须是：

应用于所有用户控制的数据
定义可以接受的字符类型（通常是U + 0020到U + 007E，虽然大多数特殊字符可以被删除，而控制字符几乎不需要）
定义数据的最小和最大长度（例如{1,25}）
良好输入验证方法的示例 对于每个字段，定义可接受字符的类型和输入的可接受字符数

用户名：字母，数字，某些特殊字符，3至10个字符
名字：字母，单撇号，短划线，1到30个字符
简单的美国邮编：数字，5个字符
注意：这些只是举例说明白名单输入验证的想法。您需要根据您期望的输入类型进行调整。

JavaScript与服务器端验证
请注意，任何JavaScript输入验证都可以被禁用JavaScript或使用Web代理的攻击者绕过。确保JavaScript执行的任何输入验证也在服务器端执行。

积极的方法
攻击的变化是巨大的。使用正则表达式来定义什么是好的，然后拒绝输入，如果收到其他东西。换句话说，我们想要使用“接受已知好”的方法而不是“拒绝已知错误”

 示例字段接受用户名。一个好的正则表达式就是验证
 该数据由以下[0-9a-zA-Z] {3,10}组成。数据
 如果不匹配则被拒绝。  
 坏的方法是建立一个恶意字符串列表，然后 
 只需确认用户名不包含错误的字符串即可。这个
 方法引发了这个问题，你是否想过所有可能的坏字符串？
强大的输入验证功能
在使用应用程序之前，从用户接收的所有数据应被视为恶意并进行验证。这包括以下内容

表格数据
网址参数
隐藏的领域
Cookie数据
HTTP头
基本上，HTTP请求中的任何内容
验证富用户内容
验证用户提交的丰富内容非常困难。考虑更正式的方法，如HTML净化器（PHP）或AntiSamy或漂白剂（Python）

输出编码
输出编码是防止XSS和注入攻击的主要方法。输入验证有助于最大限度地减少引入格式错误的数据，但它是次要控制。

关注的攻击：跨站点脚本，SQL / OS / LDAP / XML注入

防止XSS
所有受控制的用户数据必须在html页面返回时进行编码，以防止执行恶意数据（例如XSS）。例如，<script>将作为＆lt; script＆gt;返回。
编码类型特定于用户控制数据插入页面的上下文。例如，HTML实体编码适用于放入HTML主体的数据。但是，放置在脚本中的用户数据需要JavaScript特定的输出编码
这里有关于XSS预防的详细信息：OWASP XSS预防备忘单

防止SQL注入
使用用户控制的数据构建S​​QL语句的任何部分的字符串连接会产生SQL注入漏洞。
参数化查询是防止SQL注入的有保证的方法。
总是知道一段数据是否由用户控制是不现实的，因此只要方法/函数接受数据并将此数据用作SQL语句的一部分，就应该使用参数化查询。
进一步阅读：SQL注入预防备忘单

防止OS注入
尽可能避免将用户控制的数据发送到操作系统
确保有一个强大的转义例程，以防止用户添加可以由操作系统执行的其他字符（例如用户追加恶意数据，然后执行另一个操作系统命令）。记得在构建转义路由时使用积极的方法。例
进一步阅读：回顾操作系统注入代码

防止XML注入
与OS注入相同的方法。除了现有的输入验证之外，还定义了一种转义/编码可解释为xml的字符的积极方法。至少包括以下内容：<>“'＆
如果接受原始XML，则需要更强大的验证。这可能很复杂。请联系基础架构安全团队进行进一步讨论
跨域
关注的攻击：跨站点请求伪造（CSRF），恶意构架（点击劫持），第三方脚本，与第三方网站的不安全交互

防止CSRF
攻击者创建一个自签名表单或图像标签，代表经过身份验证的用户执行操作。在这里了解更多关于这种攻击类型

任何状态改变操作都需要一个安全的随机标记（例如CSRF标记）来防止CSRF攻击
CSRF令牌的特征
每个用户和每个用户会话都是唯一的
绑定到单个用户会话
大的随机值
由密码安全的随机数生成器生成
如果通过GET进行状态更改操作，CSRF令牌将作为表单的隐藏字段或URL中的隐藏字段添加
如果CSRF令牌未通过验证，服务器将拒绝请求的操作
注意：一些框架（如django）提供这种功能。从框架中使用已建立的CSRF保护，而不是创建自己的。

防止恶意网站框架（ClickJacking）
一种较新的攻击，使用页面分层和框架说服用户点击或在屏幕的特定部分输入数据。这些操作实际上被发送到带框的网站，以执行受害者用户不知道的操作。在这里了解更多关于这种攻击类型

为包含HTML内容的所有响应设置x-frame-options标头。可能的值是“DENY”或“SAMEORIGIN”。

DENY会阻止任何网站（不管域名）构架内容。
SAMEORIGIN将阻止所有网站取景，但网站内的网站除外
同一个域名。

建议使用“DENY”设置，除非已确定特定的帧需要。

代码示例

第三方脚本
使用第三方脚本时应谨慎考虑。虽然我确信每个人都会进行初步审核，但应该对审核脚本的更新进行相同的尽职调查。
确保使用的任何脚本都在本地托管，而不是从第三方站点动态引用。
与Twitter，Facebook等连接
如果使用OAuth，请确保整个通信链通过HTTPS。这包括初始OAuth请求和作为参数传递的任何URL。
如果重定向到应用程序本身的登录页面，请确保URL是HTTPS，并且所选URL不会简单地重定向到HTTP版本
确保“tweet this”或“像这样”按钮不会简单地通过加载Mozilla网页的按钮生成对第三方网站的请求（例如，没有用户的意图通过点击按钮没有请求第三方网站）
安全传输
关注的攻击：中间人，密码盗窃，会话ID盗用

何时使用SSL / TLS
必须通过HTTPS提供从登录页面到注销页面的所有点。
确保通过HTTPS访问用户完成登录表单的页面。除了通过HTTPS发布表单之外。
所有经过身份验证的页面都必须通过HTTPS提供。这包括css，脚本，图像。如果不这样做，会为中间人攻击中的人员创建一个向量，并且还会导致浏览器显示混合的SSL警告消息。
不允许HTTP访问安全页面
切勿通过HTTP提供经过验证的页面或登录页面。HTTPS应该用于登录登录页面和所有后续的认证页面。
最安全的方法是在用户请求HTTP页面指示用户书签或键入HTTPS页面以供将来使用时显示警告。但是，更常见的方法是仅将HTTP请求重定向到HTTPS等效页面。
更多关于SSL / TLS设计的信息可以在这里找到

实施STS
在可能的情况下，我们应该利用STS标题。

内容安全策略（CSP）
开发没有内联JavaScript的网站，因此采用CSP更容易

https://developer.mozilla.org/en/Introducing_Content_Security_Policy

记录
请参阅安全/用户和日志

管理员登录页面
以下是使用管理页面的任何网站的一般拦截器：

1.控制措施可以防止蛮力攻击
选项（这些都很好）：

ssl vpn后面的管理页面（最受欢迎的选项）
账户锁定
CAPTCHA的5次登录失败
访问管理页面的IP限制
2.登录页面和所有管理页面均通过HTTPS独占访问。任何访问HTTP页面的尝试都会重定向到HTTPS

3.会话ID使用SECURE标志

4.会话ID使用HTTPOnly标志

安全配置Wordpress管理页面

上传
关注点攻击：包含JavaScript，HTML或其他可执行代码的错误用户上传，任意文件覆盖

一般上传
上传验证

使用输入验证来确保上传的文件名使用预期的扩展类型
确保上传的文件不大于定义的最大文件大小
上传存储

使用新文件名将文件存储在操作系统上。请勿为此文件名或临时文件名使用任何用户控制的文本。
将所有用户上传的文件存储在不同的域（例如mozillafiles.net vs mozilla.org）。应对档案进行恶意内容分析（反恶意软件，静态分析等）
上传内容的公开服务

确保图像的正确内容类型（例如image / jpeg，application / x-xpinstall）
谨防“特殊”文件

上传功能应该使用白名单方法来仅允许特定的文件类型和扩展名。但是，重要的是要注意以下文件类型，如果允许，可能会导致安全漏洞。
“crossdomain.xml”允许在Flash，Java和Silverlight中加载跨域数据。如果在具有身份验证的网站上允许，这可以允许跨域数据盗窃和CSRF攻击。请注意，根据特定的插件版本，这可能会变得非常复杂，因此最好禁止名为“crossdomain.xml”或“c​​lientaccesspolicy.xml”的文件。
“.htaccess”和“.htpasswd”以每个目录为基础提供服务器配置选项，并且不应该被允许。请参阅http://en.wikipedia.org/wiki/Htaccess
图像上传
上传验证

使用图像重写库来验证图像是否有效并去除多余的内容。
根据图像处理中检测到的图像内容类型（例如，不要只信任上传头），将存储图像的扩展名设置为有效的图像扩展名。
确保图像的检测内容类型在已定义图像类型（jpg，png等）的列表中
存档上传
上传验证

确保归档中每个文件的解压缩大小不大于定义的最大大小
确保上传的存档与预期的类型匹配（例如，zip，rar，gzip等）
对于结构化上载（如加载项），请确保归档文件中的层次结构包含所需的文件
错误处理
关注的攻击：敏感信息泄露，系统信息泄露，帮助利用其他漏洞

用户面临错误消息
显示给用户的错误消息不应包含系统，诊断或调试信息。

调试模式
调试模式由许多应用程序和框架支持，并且可以被Mozilla应用程序接受。但是，只应在阶段中启用调试模式。

格式化错误消息
错误消息通常记录到在Web浏览器中查看的文本文件或文件。

基于文本的日志文件：确保适当处理任何换行符（％0A％0C）以防止日志伪造
基于Web的日志文件：确保任何记录的html字符都经过适当编码，以防止在查看日志时出现XSS
推荐的错误处理设计
将必要的错误数据记录到系统日志文件中
向用户显示通用错误消息
如有必要，向映射到日志文件中的错误数据的用户提供错误代码。报告错误的用户可以提供此代码来帮助诊断问题