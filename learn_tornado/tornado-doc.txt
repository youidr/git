引入模块
import tornado.httpserver
import tornado.ioloop
import tornado.options
import tornado.web
这四个都是 Tornado 的模块，在本例中都是必须的。它们四个在一般的网站开发中，都要用到，基本作用分别是：

tornado.httpserver：这个模块就是用来解决 web 服务器的 http 协议问题，它提供了不少属性方法，实现客户端和服务器端的互通。
                    Tornado 的非阻塞、单线程的特点在这个模块中体现。
tornado.ioloop：这个也非常重要，能够实现非阻塞 socket 循环，不能互通一次就结束呀。
tornado.options：这是命令行解析模块，也常用到。
tornado.web：这是必不可少的模块，它提供了一个简单的 Web 框架与异步功能，从而使其扩展到大量打开的连接，使其成为理想的长轮询。

还有一个模块引入，是用 from...import 完成的

from tornado.options import define, options
define("port", default=8000, help="run on the given port", type=int)
这两句就显示了所谓“命令行解析模块”的用途了。在这里通过 tornado.options.define() 定义了访问本服务器的端口，

定义请求-处理程序类
class IndexHandler(tornado.web.RequestHandler):
    def get(self):
        greeting = self.get_argument('greeting', 'Hello')
        self.write(greeting + ', welcome you to read: www.itdiffer.com')
就定义了一个类，名字是 IndexHandler，当然，名字可以随便取了，
但是，按照习惯，类的名字中的单词首字母都是大写的，并且如果这个类是请求处理程序类，那么就最好用 Handler 结尾，这样在名称上很明确，是干什么的。
类 IndexHandler 继承 tornado.web.RequestHandler,其中再定义 get() 和 post() 两个在 web 中应用最多的方法的内容
在本例中，只定义了一个 get() 方法。
用 greeting = self.get_argument('greeting', 'Hello') 的方式可以得到 url 中传递的参数，比如
接下来的那句 self.write(greeting + ',weblcome you to read: www.itdiffer.com)'中，write() 方法主要功能是向客户端反馈信息。
main() 方法
if __name__ == "__main__",这个方法跟以往执行 Python 程序是一样的。
tornado.options.parse_command_line(),这是在执行 tornado 的解析命令行。
在 tornado 的程序中，只要 import 模块之后，就会在运行的时候自动加载，不需要了解细节，但是，在 main（）方法中如果有命令行解析，必须要提前将模块引入。
Application 类
下面这句是重点：
app = tornado.web.Application(handlers=[(r"/", IndexHandler)])
将 tornado.web.Application 类实例化。
这个实例化，本质上是建立了整个网站程序的请求处理集合，然后它可以被 HTTPServer 做为参数调用，实现 http 协议服务器访问。Application 类的__init__方法参数形式：

def __init__(self, handlers=None, default_host="", transforms=None,**settings):
    pass
在一般情况下，handlers 是不能为空的，因为 Application 类通过这个参数的值处理所得到的请求。
例如在本例中，handlers=[(r"/", IndexHandler)]，就意味着如果通过浏览器的地址栏输入根路径（http://localhost:8000 就是根路径，
如果是 http://localhost:8000/qiwsir，就不属于根，而是一个子路径或目录了），对应着就是让名字为 IndexHandler 类处理这个请求。
通过 handlers 传入的数值格式，一定要注意，在后面做复杂结构的网站是，这里就显得重要了。
它是一个 list，list 里面的元素是 tuple，tuple 的组成包括两部分，一部分是请求路径，另外一部分是处理程序的类名称。
注意请求路径可以用正则表达式书写(关于正则表达式，后面会进行简要介绍)。举例说明：

handlers = [
    (r"/", IndexHandlers),              #来自根路径的请求用 IndesHandlers 处理
    (r"/qiwsir/(.*)", QiwsirHandlers),  #来自 /qiwsir/ 以及其下任何请求（正则表达式表示任何字符）都由 QiwsirHandlers 处理
]
HTTPServer 类
实例化之后，Application 对象（用app做为标签的）就可以被另外一个类 HTTPServer 引用，形式为：

http_server = tornado.httpserver.HTTPServer(app)
HTTPServer 是 tornado.httpserver 里面定义的类。
HTTPServer 是一个单线程非阻塞 HTTP 服务器，执行 HTTPServer 一般要回调 Application 对象，并提供发送响应的接口,
也就是下面的内容是跟随上面语句的（options.port 的值在 IndexHandler 类前面通过 from...import.. 设置的）。

http_server.listen(options.port)
这种方法，就建立了单进程的 http 服务。
IOLoop 类
剩下最后一句了：
tornado.ioloop.IOLoop.instance().start()
这句话，总是在__main()__的最后一句。表示可以接收来自 HTTP 的请求了。

一个基本框架
建立一个目录，在这个目录中建立一些子目录和文件。

/.
|
handlers
|
methods
|
static
|
templates
|
application.py
|
server.py
|
url.py

handlers：我准备在这个文件夹中放前面所说的后端 Python 程序，主要处理来自前端的请求，并且操作数据库。
methods：这里准备放一些函数或者类，比如用的最多的读写数据库的函数，这些函数被 handlers 里面的程序使用。
static：这里准备放一些静态文件，比如图片，css 和 javascript 文件等。
templates：这里放模板文件，都是以 html 为扩展名的，它们将直接面对用户。
另外，还有三个 Python 文件，依次写下如下内容。这些内容的功能，已经在上节中讲过，只是这里进行分门别类。

url.py 文件

#!/usr/bin/env Python
# coding=utf-8
"""
the url structure of website
"""

import sys     #utf-8，兼容汉字
reload(sys)
sys.setdefaultencoding("utf-8")

from handlers.index import IndexHandler    #假设已经有了

url = [
    (r'/', IndexHandler),
]
url.py 文件主要是设置网站的目录结构。
from handlers.index import IndexHandler，虽然在 handlers 文件夹还没有什么东西，为了演示如何建立网站的目录结构，
假设在 handlers 文件夹里面已经有了一个文件 index.py，它里面还有一个类 IndexHandler。在 url.py 文件中，将其引用过来。
变量 url 指向一个列表，在列表中列出所有目录和对应的处理类。
比如 (r'/', IndexHandler),，就是约定网站根目录的处理类是 IndexHandler，即来自这个目录的 get() 或者 post() 请求，均有 IndexHandler 类中相应方法来处理。
如果还有别的目录，如法炮制。
application.py 文件

#!/usr/bin/env Python
# coding=utf-8

from url import url

import tornado.web
import os

settings = dict(
    template_path = os.path.join(os.path.dirname(__file__), "templates"),
    static_path = os.path.join(os.path.dirname(__file__), "statics")
    )

application = tornado.web.Application(
    handlers = url,
    **settings
    )
from url import url 是将 url.py 中设定的目录引用过来。
setting 引用了一个字典对象，里面约定了模板和静态文件的路径，即声明已经建立的文件夹"templates"和"statics"分别为模板目录和静态文件目录。
接下来的 application 就是一个请求处理集合对象。请注意 tornado.web.Application() 的参数设置：
tornado.web.Application(handlers=None, default_host='', transforms=None, **settings)
关于 settings 的设置，不仅仅是文件中的两个，还有其它，比如，如果填上 debug = True 就表示出于调试模式。
调试模式的好处就在于有利于开发调试，但是，在正式部署的时候，最好不要用调试模式。
其它更多的 settings 可以参看官方文档：http://tornado.readthedocs.org/en/latest/web.html

server.py 文件

这个文件的作用是将 tornado 服务器运行起来，并且囊括前面两个文件中的对象属性设置。

#!/usr/bin/env Python
# coding=utf-8

import tornado.ioloop
import tornado.options
import tornado.httpserver

from application import application

from tornado.options import define, options

define("port", default = 8000, help = "run on the given port", type = int)

def main():
    tornado.options.parse_command_line()
    http_server = tornado.httpserver.HTTPServer(application)
    http_server.listen(options.port)

    print "Development server is running at http://127.0.0.1:%s" % options.port
    print "Quit the server with Control-C"

    tornado.ioloop.IOLoop.instance().start()

if __name__ == "__main__":
    main()

methods 中建立一个文件 db.py
import MySQLdb
conn = MySQLdb.connect(host="192.168.2.253", user="root", passwd="netsky13", db="blogs", port=3306, charset="utf8")    #连接对象
cur = conn.cursor()    #游标对象

在 handlers 里面建立 index.py 文件，并写入如下代码：

#!/usr/bin/env Python
# coding=utf-8

import tornado.web

class IndexHandler(tornado.web.RequestHandler):
    def get(self):
        self.render("index.html")

回到 handlers 目录中。因为这里面的文件要在别处被当做模块引用，
所以，需要在这里建立一个空文件，命名为__init__.py。这个文件非常重要。
在编写模块一节中，介绍了引用模块的方法。但是，那些方法有一个弊端，就是如果某个目录中有多个文件，就显得麻烦了。
其实 Python 已经想到这点了，于是就提供了__init__.py 文件，只要在该目录中加入了这个文件，该目录中的其它 .py 文件就可以作为模块被 Python 引入了。
至此，一个带有表单的 tornado 网站就建立起来了。读者可以回到上一级目录中，找到 server.py 文件，运行它：

要是用 ajax() 方法，需要修改 script.js 文件内容即可：
$(document).ready(function(){
    $("#login").click(function(){
        var user = $("#username").val();
        var pwd = $("#password").val();
        var pd = {"username":user, "password":pwd};
        $.ajax({
            type:"post",
            url:"/",
            data:pd,
            cache:false,
            success:function(data){
                alert(data);
            },
            error:function(){
                alert("error!");
            },
        });
    });
});
jQuery 中的 ajax() 方法使用比较简单，正如上面代码所示，只需要 $.ajax() 即可，不过需要对上面的参数进行说明。

type：post 还是 get。关于 post 和 get 的区别，可以阅读：HTTP POST GET 本质区别详解
url：post 或者 get 的地址
data：传输的数据，包括三种：（1）html 拼接的字符串；（2）json 数据；（3）form 表单经 serialize() 序列化的。本例中传输的就是 json 数据，这也是经常用到的一种方式。
cache：默认为 true，如果不允许缓存，设置为 false.
success：请求成功时执行回调函数。本例中，将返回的 data 用 alert 方式弹出来。
读者是否注意到，我在很多地方都用了 alert() 这个东西，目的在于调试，走一步看一步，看看得到的数据是否如自己所要。也是有点不自信呀。
error：如果请求失败所执行的函数。

后端接受数据
前端通过 ajax 技术，将数据已 json 格式传给了后端，并且指明了对象目录"/"，这个目录在 url.py 文件中已经做了配置，是由 handlers 目录的 index.py 文件的 IndexHandler 类来出来。
因为是用 post 方法传的数据，那么在这个类中就要有 post 方法来接收数据。所以，要在 IndexHandler 类中增加 post()，增加之后的完善代码是：
def post(self):
        username = self.get_argument("username")
        password = self.get_argument("password")
        self.write(username)

在 post() 方法中，使用 get_argument() 函数来接收前端传过来的数据，这个函数的完整格式是 get_argument(name, default=[], strip=True)，它能够获取 name 的值。
在上面的代码中，name 就是从前端传到后端的那个 json 对象的键的名字，是哪个键就获取该键的值。
如果获取不到 name 的值，就返回 default 的值，但是这个值默认是没有的，如果真的没有就会抛出 HTTP 400。
特别注意，在 get 的时候，通过 get_argument() 函数获得 url 的参数，如果是多个参数，就获取最后一个的值。
要想获取多个值，可以使用 get_arguments(name, strip=true)。
上例中分别用 get_argument() 方法得到了 username 和 password，并且它们都是 unicode 编码的数据。

tornado.web.RequestHandler 的方法 write()，即上例中的 self.write(username)，是后端向前端返回数据。
这里返回的实际上是一个字符串，也可返回 json 字符串。

验证用户名和密码
在 methods 目录中db.py文件，添加代码如下：
def select_table(table, column, condition, value ):
    sql = "select " + column + " from " + table + " where " + condition + "='" + value + "'"
    cur.execute(sql)
    lines = cur.fetchall()
    return lines

进一步改写 index.py 中的 post() 方法。为了明了，将 index.py 的全部代码呈现如下：
 def post(self):
        username = self.get_argument("username")
        password = self.get_argument("password")
        user_infos = mrd.select_table(table="users",column="*",condition="username",value=username)
        if user_infos:
            db_pwd = user_infos[0][2]
            if db_pwd == password:
                self.write("welcome you: " + username)
            else:
                self.write("your password was not right.")
        else:
            self.write("There is no thi user.")

模板

tornado 提供比较好用的前端模板(tornado.template)。通过这个模板，能够让前端编写更方便。